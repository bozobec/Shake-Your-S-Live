# -*- coding: utf-8 -*-
# Run this app with `python app.py` and
# visit http://127.0.0.1:8050/ in your web browser.
import dash
import dash_mantine_components as dmc
from dash import dcc
from dash import callback
from dash.dependencies import Input, Output, State
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import dataAPI
import main
import dash_bootstrap_components as dbc
from dash import html
import datetime
import math
from plotly.subplots import make_subplots
from dash_iconify import DashIconify

pd.set_option('display.max_columns', None)
external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']
# app = dash.Dash(__name__, external_stylesheets=external_stylesheets)
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.LUX])
app.title = 'GROOWT'
server = app.server
# ---------------------------------------------------------------------------
# Data Definition & Initialization
r_squared_selected = 0.0
carrying_capacity_container = 0
time_plateau_container = 0.0
current_valuation_container = 0.0
arpu_needed_container = 0.0
user_value_container = 0.0
valuation_Snapchat = 119.85 * pow(10, 9)
valuation_Spotify = 47.2 * pow(10, 9)
valuation_Twitter = 51.74 * pow(10, 9)
valuation_Linkedin = 29.5 * pow(10, 9)
valuation_Netflix = 282.36 * pow(10, 9)
valuation_Tesla = 1000 * pow(10, 9)
valuation_Teladoc = 23.1 * pow(10, 9)

# Values for the dropdown (all different companies in the DB)
labels = dataAPI.get_airtable_labels()

# ------------------------------------------------------------------------------------------------------------
# Components definition
# Dropdown - Taking data from "Labels"
dropdown_items = []
for i in labels:
    dropdown_items.append(dbc.DropdownMenuItem(i))
dropdown = dcc.Dropdown(id='dropdown', options=[{'label': i, 'value': i} for i in labels])
dropdown2 = dbc.DropdownMenu(id='dropdown2', label="Select dataset", children=dropdown_items)
dropdown3 = dbc.DropdownMenu(id='dropdown3', label="Select dataset", children=[dbc.DropdownMenuItem(i) for i in labels])
dropdown4 = dbc.DropdownMenu(id='dropdown4', label="Select dataset", children=[dbc.DropdownMenuItem(i) for i in labels])
dropdown5 = dcc.Dropdown(id='dropdown5', placeholder="awdsfsdfsadf", options=[{'label': i, 'value': i} for i in labels])
dropdown6 = html.Div(
    [
        dmc.Select(
            # label="Select framework",
            placeholder="Dataset...",
            id="dataset-selection",
            # value="ng",
            data=labels,
            style={"marginBottom": 10},
            dropdownPosition="bottom",
        )
    ]
)

# OffCanvas (side panel that opens to give more information)
offcanvas = html.Div(
    [
        dbc.Button("About", id="open-offcanvas", n_clicks=0),
        dbc.Offcanvas([
            dmc.Container(children=[
                dmc.Text(
                    "GROOWT is a powerful and user-friendly resource designed to help you analyze and predict the future "
                    "trajectory of selected datasets. With this tool, you can gain valuable insights into the growth "
                    "patterns of your chosen dataset, allowing you to make informed decisions and projections.", size="sm"),
                dmc.Space(h=15),
                dmc.Text("GROOWT's key features include:", size="sm"),
                dmc.Space(h=10),
                dmc.List([
                    dmc.ListItem([dmc.Text("Dataset Selection", weight=700),"Easily choose the dataset you want to analyze from the dropdown menu. "
                    "The tool supports a wide range of datasets, enabling you to select the one that suits your needs."]),
                    dmc.ListItem([dmc.Text("Historical Data Visualization", weight=700),"Visualize the historical data of your selected dataset, providing "
                    "a clear overview of its past performance and growth trends. This visualization helps you understand "
                    "how the dataset has evolved over time."]),
                    dmc.ListItem([dmc.Text("Predictive Analysis", weight=700),"Leverage the advanced predictive capabilities of GROOWT to forecast the "
                    "future growth of your dataset."]),
                    dmc.ListItem([dmc.Text("Customization Options", weight=700),"Tailor your analysis by adjusting parameters ""and variables to fine-tune your "
                    "predictions. The tool offers flexibility in adapting the analysis to your specific requirements."]),
                    dmc.ListItem([dmc.Text("Decision Support", weight=700)," Use the insights generated by the Growth Estimation Tool to inform your "
                    "decision-making processes. Whether you're a data analyst, business strategist, or simply curious "
                    "about the dataset's future, this tool provides the information you need to plan and strategize "
                    "effectively."]),
                ], size="sm", listStyleType="decimal"),
                dmc.Space(h=15),
                dmc.Text("With the GROOWT, you can explore the potential future outcomes of your dataset, "
                    "helping you make more informed choices and better understand the dynamics of the data"
                    " you're working with. If you're tracking financial metrics, website traffic, or any other "
                    "data-driven variable, this tool empowers you to harness the power of data for better decision-making."
                , size="sm"),
                dmc.Space(h=15),
                dmc.Text("Contact: groowt@proton.me")]
            ),
        ],
            id="offcanvas",
            title="Welcome to GROOWT",
            is_open=False,
        ),
    ]
)

# Navbar

navbar2 = dbc.Navbar(
            dbc.Container([
                    html.A(
                        dbc.Row(
                            [dbc.Col([html.Img(src="/assets/Vector_white.svg", style={'height': '20px'}),
                                dbc.NavbarBrand("GROOWT", style={'margin-left': '10px'})
                                     ], className="align-items-center d-flex"),
                            ]
                        ), href="https://fathomless-scrubland-44017-2a7f83d10555.herokuapp.com/"
                    ),
                    ],
            fluid=True), color="primary", dark=True)

navbar = dbc.Navbar(
    dbc.Container(
        dbc.Row(
            [
                dbc.Col(
                    html.A(
                        dbc.Row([
                            dbc.Col(
                                [
                                    html.Img(src="/assets/Vector_white.svg", style={'height': '25px'}),
                                    dbc.NavbarBrand("GROOWT", style={'margin-left': '20px'}),
                                    #dropdown5,
                                ], className="align-items-center d-flex"
                            ),
                            dbc.Col(
                                [
                                    dbc.NavItem(dbc.NavLink("About", n_clicks=0, href="#")),
                                ], className="align-items-center d-flex",
                            ),
                        ]),
                    )
                ),
            ],
        ),
        fluid=True
    ),
    color="primary",
    dark=True
)

navbar3 = dbc.Navbar(dbc.Nav(
    [
        dbc.NavItem(),
        dbc.NavItem(html.Img(src="/assets/Vector_white.svg", style={'height': '20px'})),
        dbc.NavItem(dbc.NavbarBrand("GROOWT", style={'margin-left': '20px'})),
        #dropdown4,
        #dbc.NavItem(dropdown5),
        dbc.NavItem(offcanvas, style={'height':'20px'}),
    ], fill=True
                    ),

    color="primary",
    dark=True)

navbar6 = dbc.Navbar(
    dbc.Container(
        [
            dbc.Row([
                    dbc.Col(html.Img(src="/assets/Vector_white.svg", height="25px")),
                    dbc.Col(dbc.NavbarBrand("GROOWT", className="ms-2"))
                    ],
                    align="bottom",
                    className="g-0"),

            dbc.Row([
                dbc.Col([
                    dbc.Nav([
                        dbc.NavItem(offcanvas),
                    ],
                        navbar=True
                    )
                ],
                    width={"size": "auto"})
            ],
                align="left"),
            # dbc.Col(dbc.NavbarToggler(id="navbar-toggler", n_clicks=0)),
        ],
        fluid=True
    ),
    color="primary",
    dark=True,
)


# Tooltips
tooltip_plateau = dbc.Tooltip("This number highlights the maximum amount of users that will be reached with the selected scenario",
                       target="plateau-header",)
# Sliders
slider = html.Div(children=[dcc.RangeSlider(id="range-slider-data-ignored1", min=0, step=1,
                                                               marks={},
                                                               value=[0],
                            tooltip={"placement": "bottom", "always_visible": True},
                                            vertical=True),
                            html.Div(id="max-label")])
slider_history = html.Div(children=[dcc.RangeSlider(id="range-slider-history", min=0, max=10,
                                                               marks={},
                                                               value=[10],
                                                            tooltip={"placement": "bottom", "always_visible": True}),
                            html.Div(id="max-label2")])
# slider_profitability = html.Div(children=[dcc.RangeSlider(id="range-slider-profitability", min=20, max=50, step=5,
                                                               # marks={20: '20% Profitability', 50: '50% Profitability'},
                                                               # value=[20])])
# Table summarising insights
row1 = html.Tr([html.Td(["Users ", html.Span("plateau: ", id="tooltip-plateau-target", style={"textDecoration": "underline", "cursor": "pointer"},)], style={"width": "380px"}),
                        html.Td(id='carrying-capacity', children=carrying_capacity_container, style={"color": '#54c4f4'}), tooltip_plateau], style={"margin-bottom": "0px"})
row2 = html.Tr([html.Td("Plateau reached in: "), html.Td(id='time-plateau', children=time_plateau_container, style={"color": '#54c4f4'})])
# row3 = html.Tr([html.Td("Current valuation: "), html.Td(id='current-valuation', children=current_valuation_container)])
# row4 = html.Tr([html.Td("Yearly profit per user to justify the current valuation: "),
# html.Td(id='arpu-needed', children=arpu_needed_container, style={"color": '#54c4f4'})])
# row5 = html.Tr([html.Td("R Squared: "), html.Td(id='rsquared-container', children=r_squared_selected, style={"color": '#54c4f4'})])
# row6 = html.Tr([html.Td("Current user value: "), html.Td(id='uservalue-container', children=user_value_container)])

# Left card consolidating all the rows defined above
left_card = dbc.Card(id="left-card", children=[
                    dbc.CardBody(
                        [
                            # R squared text and value displayed
                            html.Span([
                                html.H6("Prediction data"),
                                dbc.Table(html.Tbody(row1), style={"margin-bottom": "0px"}),
                                # html.Div(slider, style={"height": "10px", "margin-bottom": "20px"}),
                                # dbc.Table(html.Tbody(row4), style={"margin-bottom": "0px"}),
                                # html.Div(slider_profitability, style={"height": "10px", "margin-bottom": "40px"}),
                                dbc.Table(html.Tbody([row2])),
                            ]),
                        ])
                ], style={'display': 'none'}),
right_card = dbc.Card(id="right-card")
'''
# Card that contains the main graph with the prediction (OLD)
right_card = dbc.Card(id="right-card", children=[
                        html.Div(id='graph-container1', children=[dcc.Graph(id='main-graph1',
                                                                            config={'displayModeBar': False})])
                      ], style={'display': 'none'})
                      '''
# Card that contains the regression
bottom_card = dbc.Card(id="bottom-card", children=[
                        html.Div(id='graph-container2', children=[dcc.Graph(id='main-graph2',
                                                                            config={'displayModeBar': False})])
                      ], style={'display': 'none'})
# Card that contains the evolution of R square and RMSD
bottom_bottom_card = dbc.Card(id="bottom-bottom-card", children=[
                        html.Div(id='graph-container3', children=[dcc.Graph(id='main-graph3',
                                                                            config={'displayModeBar': False})])
                      ], style={'display': 'none'})
# Card containing the history slider
top_card = dbc.Card(id="top-card", children=[
                        dbc.CardBody(
                            [
                            html.Span([html.H6("Date of the prediction"),
                            html.Div(slider_history, style={"height": "10px", "margin-bottom": "20px"})])
                            ])
                      ], style={'display': 'none', "height": 1})

# Card containing the vertical slider for the carrying capacity
vertical_slider_card = dbc.Card(id="vertical-slider", children=[
                        dbc.CardBody(
                            [
                            html.Span([
                            html.H6("Max", id="plateau-header"),
                            html.Div(slider)])
                            ])
                      ], style={'display': 'none'})
r_squared_card = dbc.Card(id="r-squared-card", children=[
                        dbc.CardBody(
                            [
                            html.H6(["R", html.Sup(2)], id="r-squared-header"),
                            html.P(id="rsquared-container"),
                            ])
                      ], style={'display': 'none', "height": 1})

# Mantine Components

slider_k = dmc.Slider(
            id="range-slider-k",
            min=0,
            step=1,
            value=0,
            size="sm",
            disabled=True,
            showLabelOnHover=False,
            )

# Date picker

datepicker = html.Div(
                [
                    dmc.DatePicker(
                        id="date-picker",
                        #minDate=date(2020, 8, 5),
                        #inputFormat="MMMM,YY",
                        dropdownType="modal",
                        clearable=False,
                    ),
                ]
            )

# Scenarios in the accordion
# -------
# Growth
growth_message = dmc.Alert(
    children=dmc.Text(""),
    id="growth-message",
    title="",
    color="gray"),

# Plateau
plateau_message = dmc.Alert(
    children=dmc.Text(""),
    id="plateau-message",
    title="",
    color="gray"),

# Accordion
accordion = dmc.Accordion(
    value="customization",
    variant="separated",
    radius="xl",
    children=[
        dmc.AccordionItem(
            [
                dmc.AccordionControl(
                    "Growth",
                    id="accordion-growth",
                    disabled=True,
                    icon=DashIconify(icon="uit:chart-growth", width=20)
                ),
                dmc.AccordionPanel(
                    growth_message
                ),
            ],
            value="customization",
        ),
        dmc.AccordionItem(
            [
                dmc.AccordionControl(
                    "Plateau",
                    id="accordion-plateau",
                    disabled=True,
                    icon=DashIconify(icon="radix-icons:pin-top", width=20)
                                     ),
                dmc.AccordionPanel(
                    plateau_message
                ),
            ],
            value="customization",
        ),
    ],
)

# Graph message
graph_message = dmc.Alert(
    children=dmc.Text("About the graph"),
    id="graph-message",
    title="About the prediction line",
    color="blue",
    hide="True",
    withCloseButton="True"),


# Scenario picker
data_scenarios = ["Best", "Custom"]

scenarios_picker = dmc.Stack(
    [dmc.SegmentedControl(
        data=data_scenarios,
        radius=20,
        id="scenarios-picker")],
)

# Card where dataset is selected and analysis shown

selector_card = dmc.Card(
    children=[
        dmc.Group(
            [
                dmc.Text("Dataset", weight=500),
            ],
            position="apart",
            mt="md",
            mb="xs",
        ),
        dmc.Text(
            "Select a dataset to visualize its historical data and utilize the prediction tool to forecast its future growth.",
            size="sm",
            color="dimmed",
        ),
        dmc.Space(h=10),
        dropdown6,
        dmc.Group(
                            [
                                dmc.Text("Analysis", weight=500),
                            ],
                            position="apart",
                            mt="md",
                            mb="xs",
                ),
        accordion,
    ],
    withBorder=True,
    shadow="sm",
    radius="md",
    # style={"width": 350},
)


functionalities_card = dmc.Card(
    children=[
        dmc.Group(
            [
                dmc.Text("Functionalities", weight=500),
            ],
            position="apart",
            mt="md",
            mb="xs",
        ),
        dmc.Text(
            "The following functionalities allow you to move the predicted curve or 'go back in time'",
            size="sm",
            color="dimmed",
        ),
        dmc.Space(h=10),
        dmc.Space(h=10),
        # Plateau slider
        html.Div(
            children=[
                dmc.Tooltip(
                    dmc.Group([
                        dmc.Text(
                            "Prediction",
                            size="sm",
                            weight=700,
                            ),
                        DashIconify(icon="feather:info", width=15),
                        dmc.RingProgress(
                                    id="r2-ring-progress",
                                    size=24,
                                    thickness=4,
                                    roundCaps=True,
                                    sections=[
                                        {"value": 0, "color": "LightGrey"},
                                    ]
                                ),
                        ],
                        spacing=5),
                    label="This slider allows you to move the blue curve and see how well it fits the dataset",
                    transition="slide-down",
                    transitionDuration=300,
                    multiline=True,
                ),
                dmc.Space(h=10),
                scenarios_picker,
        ]),
        dmc.Space(h=10),
        html.Div(slider_k),
        dmc.Space(h=30),

        # Datepicker
        html.Div(
            children=[
                dmc.Tooltip(
                    dmc.Group([
                        dmc.Text(
                            "Datepicker",
                            size="sm",
                            weight=700,
                            ),
                        DashIconify(icon="feather:info", width=15)
                        ],
                        spacing=5),
                    label="Pick a date in the past to see how well the current state would have been predicted back then",
                    transition="slide-down",
                    transitionDuration=300,
                    multiline=True,
                ),
                dmc.Space(h=10),
                datepicker,
        ]),
    ],
    withBorder=True,
    shadow="sm",
    radius="md",
    style={"height": 500},
)

graph_card = dmc.Card(
    children=[
        # Card Title
        dmc.Group(
                    [
                        dmc.Text("Dataset visualization and Predicted growth", id="graph-title", weight=500),
                    ],
                    position="apart",
                    mt="md",
                    mb="xs",
                ),
        dmc.Text(
                    "Select a dataset first",
                    size="sm",
                    color="dimmed",
                    id='graph-subtitle',
                ),
        dmc.Space(h=30),
        html.Div(graph_message),

        # Card Content
        html.Div(id='graph-container1',
                 children=[dcc.Graph(id='main-graph1', config={'displayModeBar': False, 'scrollZoom': True}
                                     )
                           ]
                 )],
    withBorder=True,
    shadow="sm",
    radius="md",
)

# Alert generated
alert_no_calculation_possible = dbc.Alert(
            "No estimation could be done with the selected dataset. Try another dataset and/or point in time",
            id="alert-fade",
            dismissable=True,
            is_open=False,
            color="info"
        ),

# Graph layout

# Build main graph
layout_main_graph = go.Layout(
    # title="User Evolution",
    plot_bgcolor="White",
    legend=dict(
        # Adjust click behavior
        itemclick="toggleothers",
        itemdoubleclick="toggle",
        orientation="h",
        x=0.5,
        y=-0.1,
    ),
    xaxis=dict(
        # title="Timeline",
        linecolor="Grey",
        hoverformat=".0f",
    ),
    yaxis=dict(
        title="Users",
        linecolor="Grey",
        gridwidth=1,
        gridcolor='#e3e1e1',
        # hoverformat='{y/1e6:.0f} M'
    ),
    showlegend=True,
    font=dict(
        # family="Open Sans",
        #size=16,
        # color="Black"
    ),
)

# Build second graph
layout_second_graph = go.Layout(
    # title="User Evolution",
    plot_bgcolor="White",
    legend=dict(
        # Adjust click behavior
        itemclick="toggleothers",
        itemdoubleclick="toggle",
    ),
    xaxis=dict(
        title="Users",
        linecolor="Grey",
    ),
    yaxis=dict(
        title="Discrete Growth Rate",
        linecolor="Grey",
        gridwidth=1,
        gridcolor='#e3e1e1',
    ),
    showlegend=False,
    font=dict(
        # family="Open Sans",
        #size=16,
        #color="Black"
    ),
)
# Build third graph
layout_third_graph = go.Layout(
    # title="User Evolution",
    plot_bgcolor="White",
    legend=dict(
        # Adjust click behavior
        itemclick="toggleothers",
        itemdoubleclick="toggle",
    ),
    xaxis=dict(
        title="# of Data ignored",
        linecolor="Grey",
    ),
    yaxis=dict(
        title="R^2",
        linecolor="Grey",
        gridwidth=1,
        gridcolor='#e3e1e1',
    ),
    showlegend=False,
    font=dict(
        # family="Open Sans",
        #size=16,
        #color="Black"
    ),
)


loading = dcc.Loading(id="loading-component", children=[html.Div([html.Div(id="loading-output")])], type="circle",),

# ----------------------------------------------------------------------------------
# App Layout
app.layout = html.Div(
    [navbar6,
     dmc.Space(mb=20),  # Margin/space between the navbar and the content
     # Mantine Grid

dmc.Container(fluid=True, children=[
     dmc.Grid([
        #dmc.Col(span=0.5, lg=0), # Empty left column
        dmc.Col(selector_card, span="auto"),
        dmc.Col(dmc.LoadingOverlay(graph_card), span=12, lg=6),
        dmc.Col(functionalities_card, span=12, lg=3),
        # dmc.Col(span="auto", lg=0), # Empty right column
         ],
        gutter="xl",
         justify="space-around",
         # align="center",
     ),
    ]),

     dbc.Container(children=[
        # Toast message appearing on top
        dbc.Row(html.Div(alert_no_calculation_possible)),
        #dbc.Row(navbar2),
        # dbc.Row(html.Div(dropdown2)),
        # dbc.Row(dbc.Col(navbar2, style={'clear': 'both', "margin-top": "40px"},
                        # width={"size": 7}), justify="center"),
        # Title row & loading animation
        dbc.Row(dbc.Col([
            #html.Div([html.Img(src="/assets/Vector.svg", style={'height': '35px', 'float': 'left'}),
            #         html.H1(id='main-title', style={'float': 'left', 'margin-left': '20px'}, children='GROOWT')]),
            html.Div(loading)], style={'clear': 'both', "margin-top": "40px"},
                        width={"size": 7}), justify="center"),
        # Subtitle
        # dbc.Row(dbc.Col(html.Div(children="Have fun estimating the user growth of companies"),
                        # width={"size": 6, "offset": 1})),
        # Dropdown
        # dbc.Row(dbc.Col(html.Div(dropdown), width={"size": 7}), justify="center"),
        # HighChart test
        # dbc.Row(main_chart),
        # Title - You are seeing the evolution of X company
        # dbc.Row(dbc.Col(html.H2(id='title', children=[]), width={"size": 6, "offset": 1}), style={"margin-top": "40px"}),
        # --------------------------------------------------------
        # Slider to go back in time and retrofit
        dbc.Row([
            # dbc.Col(top_card, width={"size": 6}),
            # dbc.Col(r_squared_card, width={"size": 1}),
        ], justify="center"),
        # Bloc with buttons and graph
        dbc.Row([
            # 1st column with the main graph
            dbc.Col(right_card, width={"size": 6}),
            # 2nd column with the table and the slider
            # dbc.Col(left_card, width={"size": 4}),
            # Column with the vertical slider for carrying capacity
            dbc.Col(vertical_slider_card, width={"size": 1}),
        ], style={"margin-top": "20px"}, justify="center"),
        # Bottom graph of the regression
        dbc.Row(dbc.Col(bottom_card, width={"size": 7}), style={"margin-top": "20px"}, justify="center"),
        # Bottom graph of the evolution of r^2
        dbc.Row(dbc.Col(bottom_bottom_card, width={"size": 7}), style={"margin-top": "20px"}, justify="center"),
        dbc.Row(left_card),
        # Storing the key dataframe with all parameters
        dcc.Store(id='intermediate-value'),
        dcc.Store(id='users-data')
    ], fluid=True)])


# ----------------------------------------------------------------------------------
# Callback behaviours and interaction
# Callback to enable the slider if "Custom" is selected
@app.callback([
    Output("range-slider-k", "disabled"),

    Input("scenarios-picker", "value"),
    Input("dataset-selection", "value")
    ])
def enable_slider(scenario_value, data_selection):
    print(scenario_value)
    if scenario_value == "Custom" and data_selection != None:
        return False,
    else:
        return True,

# Callback to change the Graph's title, enable the analysis buttons
@app.callback([
    Output("graph-title", "children"),
    Output("graph-subtitle", "children"),
    Output("accordion-growth", "disabled"),
    Output("accordion-plateau", "disabled"),

    Input("dataset-selection", "value")
    ],prevent_initial_call=True)
def select_value(value):
    title = value
    subtitle = "Explore "+str(value)+"'s Historical Data (Bars) and Future Growth Projections. Customize Predictions with the Slider in the 'Functionalities' Section and Adjust the Forecast Start Date Using the Datepicker."
    return title, subtitle, False, False

# Callback defining the minimum and the maximum date of the datepicker, based on the selected dataset
@app.callback([
    Output(component_id='date-picker', component_property='minDate'), # Calculate the min of the new history slider
    Output(component_id='date-picker', component_property='maxDate'), # Calculate the min of the new history slider
    Output(component_id='date-picker', component_property='value'), # Resets the date to the last available date of the dataset
    Input(component_id='dataset-selection', component_property='value')], # Take dropdown value
    prevent_initial_call=True,)

def set_history_size(dropdown_value):
    print("Fetching the dataset for ", dropdown_value)
    df = dataAPI.get_airtable_data(dropdown_value)
    print(df)
    # The dates in a panda serie of format YYYY-MM-DD are transformed to a decimal yearly array
    dates = np.array(main.date_formatting(df["Date"]))
    formatted_dates = dates + 1970
    min_history_date = main.date_minimum_history(formatted_dates)
    max_history_date = formatted_dates[-1]
    dates_unformatted = np.array(df["Date"])

    date_value_datepicker = str(dates_unformatted[-1])
    min_history_datepicker = str(dates_unformatted[4])  # Defines the minimum date that can be chosen by the user, based on the data available
    max_history_datepicker = str(dates_unformatted[-1]) # Same as above but for the max

    return min_history_datepicker, max_history_datepicker, date_value_datepicker
@app.callback(
    Output(component_id='intermediate-value', component_property='data'), #prints the dataframe
    Output(component_id='users-data', component_property='data'),
    Output(component_id='range-slider-data-ignored1', component_property='value'), # Reset slider value to zero
    Output("alert-fade", "is_open"),  # Reset slider value to zero
    # Output("loading-component", "loading"),
    Output(component_id='range-slider-k', component_property='value'), # Reset slider value to the best value
    Output(component_id="growth-message", component_property="title"),
    Output(component_id="growth-message", component_property="children"),
    Output(component_id="growth-message", component_property="color"),
    Output(component_id="growth-message", component_property="value"),
    Output(component_id="plateau-message", component_property="title"),
    Output(component_id="plateau-message", component_property="children"),
    Output(component_id="plateau-message", component_property="color"),

    # Output(component_id='range-slider-history', component_property='value'), # Set slider to the last date available
    # Output(component_id='uservalue-container', component_property='children'),
    Input(component_id='dataset-selection', component_property='value'),  # Take dropdown value
    Input(component_id='date-picker', component_property='value'), # Take date-picker date
    Input("scenarios-picker", "value"), # Input the scenario to reset the position of the slider to the best scenario
    prevent_initial_call=True)

# Analysis to load the different scenarios (low & high) when a dropdown value is selected
def load_data(dropdown_value, date_picked, scenario_value):
    print("Starting scenarios calculation")
    print(date_picked, type(date_picked))
    date_picked_formatted = main.date_formatting_from_string(date_picked)
    print(date_picked_formatted)

    # The data is loaded from airtable
    df = dataAPI.get_airtable_data(dropdown_value)
    # The dates in a panda serie of format YYYY-MM-DD are transformed to a decimal yearly array
    dates = np.array(main.date_formatting(df["Date"]))
    # Users are taken from the database and multiply by a million
    users = np.array(df["Users"]).astype(float) * 1000000
    print(df)

    # Test to be deleted, changing dates & users to use moving average
    dates, users = main.moving_average_smoothing(dates, users, 1)
    #history_value_formatted = history_value[0]-1970  # OLDPuts back the historical value to the format for computations
    history_value_formatted = date_picked_formatted-1970  # New slider: Puts back the historical value to the format for computations
    dates_actual = main.get_earlier_dates(dates, history_value_formatted)
    data_len = len(dates_actual)  # length of the dataset to consider for retrofitting

    # All parameters are calculated by ignoring data 1 by 1, taking the history reference as the end point
    df_full = main.parameters_dataframe(dates[0:data_len], users[0:data_len])  # Dataframe containing all parameters with all data ignored
    df_sorted = main.parameters_dataframe_cleaning(df_full, users[0:data_len])  # Dataframe where inadequate scenarios are eliminated
    if dropdown_value is None:  # Exception for when dropdown is not selected yet, initializing df
        df = df_full
    current_valuation = 100
    if date_picked_formatted:
        if df_sorted.empty:
            state_alert = True
        else:
            state_alert = False



    user_value = current_valuation / users[-1]
    user_value_displayed = '{:.1f} $'.format(user_value)
    formatted_dates = dates + 1970
    min_history_date = main.date_minimum_history(formatted_dates)
    max_history_date = formatted_dates[-1]

    # Best scenario ---> Index of the row containing the highest R^Square
    highest_r2_index = df_sorted['R Squared'].idxmax()


    # Scenario analysis
    # Growth: for the best growth scenario (highest R^2), if the difference between the log R^2 and the linear R^2
    #           is <0.1, then that means the growth is stabilizing and a classical logistic growth is to be expeced
    #           if it is > 0.1 then it means that the dataset is still in its exponential growth and the probability
    #           for exponential growth is high

    diff_r2lin_log = df_sorted.at[highest_r2_index, 'Lin/Log Diff']

# Growth Accordion
# Promising Growth
    if diff_r2lin_log > 0.1:
        growth_message_title = "Promising Exponential Growth Ahead!"
        growth_message_body = "Groowt's model predicts a strong likelihood of exponential growth in the foreseeable " \
                              "future, surpassing the best-case scenario displayed."
        growth_message_color = "green"

# Stable Growth
    else:
        growth_message_title = "Consistent and Predictable Growth!"
        growth_message_body = "Groowt's model suggests a high probability that the dataset has transitioned into a " \
                              "stable growth pattern, aligning closely with our best-case scenario."
        growth_message_color = "yellow"

# Plateau definition & time to 90% of the plateau

    k_scenarios = np.array(df_sorted['K'])
    r_scenarios = np.array(df_sorted['r'])
    p0_scenarios = np.array(df_sorted['p0'])

    # High Growth
    if k_scenarios[-1] < 1e9:
        plateau_high_growth = f"{k_scenarios[-1] / 1e6:.1f} M"
    else:
        plateau_high_growth = f"{k_scenarios[-1] / 1e9:.1f} B"
    time_high_growth = main.time_to_population(k_scenarios[-1], r_scenarios[-1], p0_scenarios[-1],
                                               k_scenarios[-1]*0.9)+1970
    # Low Growth
    if k_scenarios[0] < 1e9:
        plateau_low_growth = f"{k_scenarios[0] / 1e6:.1f} M"
    else:
        plateau_low_growth = f"{k_scenarios[0] / 1e9:.1f} B"
    time_high_growth = main.time_to_population(k_scenarios[0], r_scenarios[0], p0_scenarios[0],
                                               k_scenarios[0] * 0.9)+1970
    # Best Growth
    if k_scenarios[highest_r2_index] < 1e9:
        plateau_best_growth = f"{k_scenarios[highest_r2_index] / 1e6:.1f} M"
    else:
        plateau_best_growth = f"{k_scenarios[highest_r2_index] / 1e9:.1f} B"
    time_best_growth = main.time_to_population(k_scenarios[highest_r2_index],
                                               r_scenarios[highest_r2_index],
                                               p0_scenarios[highest_r2_index],
                                               k_scenarios[highest_r2_index] * 0.9)+1970

# Plateau Accordion
    if diff_r2lin_log > 0.1:
        plateau_message_title = "Plateau could be reached in " + main.string_formatting_to_date(time_high_growth) \
                               + " with " + str(plateau_high_growth) + " users "
        plateau_message_body = "Given the likelihood of exponential growth in the foreseeable " \
                              "future, the high growth scenario is likely with a plateau at " + \
                              str(plateau_high_growth) + " users which should happen in " + main.string_formatting_to_date(time_high_growth)
    else:
        plateau_message_title = "Plateau could be reached in " + main.string_formatting_to_date(time_best_growth) \
                               + " with " + str(plateau_best_growth) + " users"
        plateau_message_body = "Given the likelihood of a stable growth in the foreseeable " \
                              "future, the best growth scenario is likely to reach its plateau in " \
                              + main.string_formatting_to_date(time_high_growth) + " with " + str(plateau_high_growth) + " users"

    # Slider Marks
    data_ignored_array = df_sorted.index.to_numpy()
    k_scenarios = np.array(df_sorted['K'])

    marks_slider = [
        {"value": 0, "label": f"      {k_scenarios[0] / 1000000:.0f}M"},
        {"value": data_ignored_array[-1], "label": f"{k_scenarios[-1] / 1000000:.0f}M      "},
    ]

    print(df_sorted)
    print("Scenarios calculation completed")
    print(highest_r2_index)
    print(df_sorted)
    return df_sorted.to_json(date_format='iso', orient='split'), df.to_json(date_format='iso', orient='split'), \
        [0], state_alert, highest_r2_index, growth_message_title, growth_message_body, growth_message_color, \
        "customization", plateau_message_title, plateau_message_body, "blue"

@app.callback([
    # Output(component_id='title', component_property='children'),  # Title

    # Output(component_id='top-card', component_property='style'),  # Show top card with slider
    # Output(component_id='left-card', component_property='style'),  # Show left card
    # Output(component_id='right-card', component_property='style'),  # Show graph card
    # Output(component_id='bottom-card', component_property='style'),  # Show graph card
    # Output(component_id='bottom-bottom-card', component_property='style'),  # Show graph card
    # Output(component_id='vertical-slider', component_property='style'),  # Show slider card
    # Output(component_id='r-squared-card', component_property='style'),  # Show r-squared card
    Output(component_id='main-graph1', component_property='figure'),  # Update graph 1
    Output(component_id='main-graph2', component_property='figure'),  # Update graph 2
    Output(component_id='main-graph3', component_property='figure'),  # Update graph 3
    Output(component_id='carrying-capacity', component_property='children'),  # Update the carrying capacity
    #Output(component_id='rsquared-container', component_property='children'),  # Update regression
    Output(component_id='r2-ring-progress', component_property='sections'),  # Update regression
    Output(component_id='time-plateau', component_property='children'),  # Update the time when the plateau is reached
    Output(component_id='range-slider-data-ignored1', component_property='marks'),  # Amount of steps for the slider, matching the number of parameters calculated
    Output(component_id='range-slider-k', component_property='max'),
    Output(component_id='range-slider-k', component_property='marks'),
    Output(component_id='graph-message', component_property='hide'),
    Output(component_id='graph-message', component_property='children'),
    ],

    [
    Input(component_id='users-data', component_property='data'),  # Take dropdown value
    Input(component_id='intermediate-value', component_property='data'), # Read data of the parameters calculated earlier
    Input(component_id='range-slider-k', component_property='value'),  # Take user slider value
    Input(component_id='date-picker', component_property='value'), # Take date-picker date
    # Input(component_id='range-slider-profitability', component_property='value')
              ])
def graph_update(jsonified_users_data, jsonified_cleaned_data, data_slider, date_picked_formatted):
    # --------- Data Loading
    # Data prepared earlier is fetched here
    df = pd.read_json(jsonified_users_data, orient='split')  # Users+date data
    #print(df)
    # Way of dynamically adapting the title --> company_name should be used as a variable
    title_figure = "The growth evolution is shown"
    dates = np.array(main.date_formatting(df["Date"]))
    users = np.array(df["Users"]).astype(float)*1000000
    # Test to be deleted, changing dates & users to use moving average
    #dates, users = main.moving_average_smoothing(dates, users, 1)

    # Gets the date selected from the new date picker
    date_picked_formatted = main.date_formatting_from_string(date_picked_formatted)
    history_value = date_picked_formatted
    # Calculating the length of historical values to be considered in the plots
    # history_value_formatted = history_value[0] - 1970  # Puts back the historical value to the format for computations
    history_value_formatted = date_picked_formatted - 1970  # New slider: Puts back the historical value to the format for computations
    dates_actual = main.get_earlier_dates(dates, history_value_formatted)
    data_len = len(dates_actual)  # length of the dataset to consider for retrofitting
    users_actual = users[0:data_len]

    df_sorted = pd.read_json(jsonified_cleaned_data, orient='split')
    print("Selected date", date_picked_formatted)
    print(df_sorted)
    df_sorted_array = np.array(df_sorted)


    # If selecting all possible scenarios,  Creation of the arrays of parameters
    df_scenarios = df_sorted
    df_scenarios_array = np.array(df_scenarios)
    k_scenarios = np.array(df_scenarios['K'])
    r_scenarios = np.array(df_scenarios['r'])
    p0_scenarios = np.array(df_scenarios['p0'])
    # ignored_data_scenarios = np.array((df_scenarios['d_ignored']))



    # Creating the slider's marks
    max_value = len(df_sorted) - 1

    '''
    marks_history = {
        min_history_date: {'label': str(int(min_history_date)), 'style': {'color': '#77b0b1'}},
        max_history_date: {'label': str(int(max_history_date)), 'style': {'color': '#f50'}}
    }'''
    # Formatting of the marks to be created for the slider
    k_min_mark1 = int(np.rint(k_scenarios[0]) / pow(10, 6))
    k_min_mark = "{:,} M".format(k_min_mark1)
    k_max_mark1 = int(np.rint(k_scenarios[-1]) / pow(10, 6))
    k_max_mark = "{:,} M".format(k_max_mark1)
    k_tooltip1 = int(np.rint(k_scenarios[data_slider]) / pow(10, 6))
    k_tooltip = "{:,} M".format(k_tooltip1)
    marks = {
        0: {'label': k_min_mark, 'style': {'color': '#f50', 'position': 'absolute', 'right': '-30px'}},
        max_value: {'label': k_max_mark, 'style': {'color': '#77b0b1', 'right': '-30px'}}
    }

    # The "marks" list now contains the desired format

    # Based on the slider's value, the related row of parameters is selected
    row_selected = data_slider
    # Parameters definition
    data_ignored_array = df_scenarios.index.to_numpy()
    k = df_scenarios_array[row_selected, 1]
    r = df_scenarios_array[row_selected, 2]
    p0 = df_scenarios_array[row_selected, 3]
    r_squared_showed = np.round(df_sorted_array[row_selected, 4], 3)
    number_ignored_data = int(df_scenarios_array[row_selected, 0])

    # R^2 Ring progress definition
    value_section = r_squared_showed*100
    if r_squared_showed > 0.9:
        sections = [
            {"value": value_section, "color": "Green", "tooltip": "Very Good"},
        ]
    elif 0.6 < r_squared_showed <= 0.9:
        sections = [
            {"value": value_section, "color": "LightGreen", "tooltip": "Good"},
        ]

    elif 0.4 < r_squared_showed <= 0.6:
        sections = [
            {"value": value_section, "color": "Yellow", "tooltip": "Medium"},
        ]

    elif r_squared_showed <= 0.4:
        sections = [
            {"value": value_section, "color": "Red", "tooltip": "Meeeeh"},
        ]

    else:
        sections = [
            {"value": value_section, "color": "LightGrey", "tooltip": "Computation issue"},
        ]

    print("Value Ring", value_section, r_squared_showed)



    highest_r2_index = df_sorted['R Squared'].idxmax()
    if k_scenarios[-1] >= 1_000_000_000:
        marks_slider = [
            {"value": 0},
            {"value": highest_r2_index, "label": "★"},
            {"value": data_ignored_array[-1], "label": f"{k_scenarios[-1] / 1000000000:.1f}B      "},
        ]
    else:
        marks_slider = [
            {"value": 0},
            {"value": highest_r2_index, "label": "★"},
            {"value": data_ignored_array[-1], "label": f"{k_scenarios[-1]/1000000:.0f}M      "},
        ]

    # Graph message

    # Selected Growth
    if k_scenarios[data_slider] < 1e9:
        plateau_selected_growth = f"{k_scenarios[data_slider] / 1e6:.1f} M"
    else:
        plateau_selected_growth = f"{k_scenarios[data_slider] / 1e9:.1f} B"
    time_selected_growth = main.time_to_population(k_scenarios[data_slider],
                                               r_scenarios[data_slider],
                                               p0_scenarios[data_slider],
                                               k_scenarios[data_slider] * 0.9)+1970

    graph_message = "Anticipated Plateau Date (blue line): " + main.string_formatting_to_date(time_selected_growth) + ", Projected at " + \
                    str(plateau_selected_growth) + " users"


    # Finding the log parameters
    df_log = main.parameters_dataframe_given_klog(dates[0:data_len], users[0:data_len])
    df_log_array = np.array(df_log)
    #index_of_k_log = df_sorted[df_sorted['Method'] == 'K set'].index[0]
    k_log = df_log_array[0, 1]
    r_log = df_log_array[0, 2]
    p0_log = df_log_array[0, 3]
    r_squared_log = np.round(df_log_array[0, 4], 3)
    number_ignored_data_log = int(df_log_array[0, 0])
    print("Number of ignored data")
    print(number_ignored_data)

    # Polynomial approximation
    logfit = main.log_approximation(dates[number_ignored_data:data_len], users[number_ignored_data:data_len])
    #k_log = np.exp(-logfit[1]/logfit[0])
    #df_log = main.parameters_dataframe_given_k(dates[0:data_len], users[0:data_len])
    #print("LOG params")
    #print(df_log)
    #polynum3 = main.polynomial_approximation(dates[number_ignored_data:data_len], users[number_ignored_data:data_len], 3)
    #polynum2 = main.polynomial_approximation(dates[number_ignored_data:data_len], users[number_ignored_data:data_len],
                                             # 2)
    #polynum1 = main.polynomial_approximation(dates[number_ignored_data:data_len], users[number_ignored_data:data_len], 1)

    # Calculating the other parameters, given K provided by the log approximation
    # r_log, p0_log, r_squared_log = main.logistic_parameters_given_K(dates[number_ignored_data:data_len],
                                                     # users[number_ignored_data:data_len], k_log)

    # Build Main Chart
    # ---------------------
    hovertemplate_maingraph = "%{text}"
    fig_main = go.Figure(layout=layout_main_graph)
    x_axis = [dates[0] + 1970, dates[-1] * 2 - dates[0] + 1970]
    fig_main.update_xaxes(range=x_axis)  # Fixing the size of the X axis with users max + 10%
    fig_main.update_yaxes(range=[0, k_scenarios[-1]*1.1])  # Fixing the size of the Y axis

    # Historical data

    # Highlight points considered for the approximation
    fig_main.add_trace(go.Bar(name="Dataset", x=dates[number_ignored_data:] + 1970,
                              y=users[number_ignored_data:data_len],
                              marker_color="Black", hoverinfo='none'))
    y_predicted = users
    formatted_y_values = [f"{y / 1e6:.1f} M" if y < 1e9 else f"{y / 1e9:.2f} B" for y in y_predicted]
    fig_main.add_trace(go.Scatter(name="Historical data", x=dates + 1970,
                              y=y_predicted, mode='lines', opacity=1,
                              marker_color="Black", showlegend=False, text=formatted_y_values, hovertemplate=hovertemplate_maingraph))
    # Highlight points not considered for the approximation
    fig_main.add_trace(
        go.Bar(name="Data omitted", x=dates[0:number_ignored_data] + 1970, y=users[0:number_ignored_data],
               marker_color="Grey", hoverinfo='none', showlegend=False))
    # Highlight points past the current date
    fig_main.add_trace(go.Bar(name="Future data", x=dates[data_len:] + 1970,
                              y=users[data_len:],
                              marker_color='#e6ecf5', hoverinfo='none',))
    # Add vertical line indicating the year of the prediction for retrofitting
    fig_main.add_vline(x=history_value, line_width=1, line_dash="dot",
                       opacity=0.5, annotation_text="   Forecast")
    # Update layout to customize the annotation
    fig_main.update_layout(
        hovermode="x unified",
        annotations=[
            dict(
                x=history_value,
                y=0.9,  # Adjust the y-position as needed
                text="   F O R E C A S T",
                showarrow=False,
                font=dict(
                    size=8,  # Adjust the size as needed
                    color="black",  # Text color
                    # letter=5,
                ),
                opacity=0.3  # Set the opacity
            )
        ],
        dragmode="pan",
    )

    # Prediction, S-Curves

    # Add S-curve - S-Curve the user can play with
    x = np.linspace(dates[0], dates[-1]*2-dates[0], num=50)
    y_predicted = main.logisticfunction(k, r, p0, x)
    formatted_y_values = [f"{y / 1e6:.1f} M" if y < 1e9 else f"{y / 1e9:.2f} B" for y in y_predicted]
    fig_main.add_trace(go.Scatter(name="Prediction", x=x+1970, y=y_predicted,
                                  mode="lines", line=dict(color='#4dabf7', width=2), opacity=0.8,
                                  text=formatted_y_values, hovertemplate=hovertemplate_maingraph))
    # Add 3 scenarios
    x0 = np.linspace(dates_actual[-1] + 0.25, dates_actual[-1]*2-dates_actual[0], num=10)  # Creates a future timeline the size of the data

    # Low growth scenario
    x_annotation = max(x0+1970)
    y_annotation = float(main.logisticfunction(k_scenarios[0], r_scenarios[0], p0_scenarios[0], [dates[-1]*2-dates[0]]))
    x = np.linspace(dates[-1], dates[-1] * 2 - dates[0], num=50)
    y_trace = main.logisticfunction(k_scenarios[0], r_scenarios[0], p0_scenarios[0], x)
    formatted_y_values = [f"{y / 1e6:.1f} M" if y < 1e9 else f"{y / 1e9:.2f} B" for y in y_trace]
    fig_main.add_trace(go.Scatter(name="Low growth", x=x + 1970,
                             y=main.logisticfunction(k_scenarios[0], r_scenarios[0], p0_scenarios[0], x), mode='lines',
                             line=dict(color='LightGrey', width=0.5), showlegend=False, text=formatted_y_values, hovertemplate=hovertemplate_maingraph)),
    #fig.add_trace(go.Line(name="Predicted S Curve", x=x + 1970,
                             #y=main.logisticfunction(k_scenarios[1], r_scenarios[1], p0_scenarios[1], x), mode="lines"))
    y_trace = main.logisticfunction(k_scenarios[-1], r_scenarios[-1], p0_scenarios[-1], x)
    formatted_y_values = [f"{y / 1e6:.1f} M" if y < 1e9 else f"{y / 1e9:.2f} B" for y in y_trace]
    # High growth scenario, if existent
    if len(df_scenarios_array) > 1:
        fig_main.add_trace(go.Scatter(name="High Growth", x=x + 1970,
                             y=y_trace, mode='lines',
                             line=dict(color='LightGrey', width=0.5),
                                      textposition="top left", textfont_size=6, showlegend=False,
                                      text=formatted_y_values, hovertemplate=hovertemplate_maingraph))

    # Filling the area of possible scenarios
    x_area = np.append(x, np.flip(x))  # Creating one array made of two Xs
    y_area_low = main.logisticfunction(k_scenarios[0], r_scenarios[0], p0_scenarios[0], x) # Low growth array
    y_area_high = main.logisticfunction(k_scenarios[-1], r_scenarios[-1], p0_scenarios[-1], np.flip(x)) # High growth array
    y_area = np.append(y_area_low, y_area_high)
    fig_main.add_trace(go.Scatter(x=x_area + 1970,
                                  y=y_area,
                                  fill='toself',
                                  line_color='LightGrey',
                                  fillcolor='LightGrey',
                                  opacity=0.2,
                                  hoverinfo='none',
                                  showlegend=False
                                  )
                       )

    # fig_main.update_traces(hovertemplate="%{x|%b %Y}")
    # Calculate custom x-axis labels based on the numeric values
    # custom_x_labels = [f"{int(val):%B %Y}" for val in x_values]

    x1 = np.linspace(dates[-1] + 0.25, dates[-1] + 10, num=10)
    # Add predicted bars
    # fig_main.add_trace(go.Bar(name="Predicted S Curve", x=x1+1970, y=main.logisticfunction(k, r, p0, x1),
                         # marker_color='White', marker_line_color='Black'))

    # Build second chart containing the discrete growth rates
    # -------------------------------------------------------
    fig_second = go.Figure(layout=layout_second_graph)
    fig_second.update_xaxes(range=[0, users[-1]*1.1])  # Fixing the size of the X axis with users max + 10%
    max_rd_value = df_sorted['r'].max()

    fig_second.update_yaxes(range=[0, max_rd_value]) # Fixing the size of the Y axis
    fig_second.add_trace(
        go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users),
                   y=main.discrete_growth_rate(users, dates+1970), mode="markers",line=dict(color='#54c4f4')))
    # Add trace of the regression
    fig_second.add_trace(
        go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users),
                   y=-r/k*main.discrete_user_interval(users)+r, mode="lines", line=dict(color='#54c4f4')))
    # Add trace of the regression obtained by fixing k
    fig_second.add_trace(
        go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users),
                   y=-r_log / k_log * main.discrete_user_interval(users) + r_log, mode="lines", line=dict(color='Purple')))
    # Changes the color of the scatters ignored
    # print(main.discrete_user_interval(users[0:number_ignored_data]))
    if number_ignored_data > 0:
        fig_second.add_trace(
            go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users[0:number_ignored_data]),
                       y=main.discrete_growth_rate(users[0:number_ignored_data], dates[0:number_ignored_data] + 1970),
                       mode="markers", line=dict(color='#808080')))

    # Changes the color of the scatters after the date considered
    if data_len < len(dates):
        fig_second.add_trace(
            go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users[data_len:]),
                       y=main.discrete_growth_rate(users[data_len:], dates[data_len:] + 1970),
                       mode="markers", line=dict(color='#e6ecf5')))

    # Build third chart containing the evolution of r^2 & rmsd
    # fig_third = go.Figure(layout=layout_third_graph)
    fig_third = make_subplots(specs=[[{"secondary_y": True}]])
    df_sorted_n_ignored = df_sorted.sort_values(by='Data Ignored')
    x_3_axis = df_sorted_n_ignored['Data Ignored']
    y_3_axis = df_sorted_n_ignored['R Squared']
    y_3_axis2 = df_sorted_n_ignored['RMSD']
    fig_third.add_trace(
        go.Scatter(name="R^2", x=x_3_axis,
                   y=y_3_axis, mode="markers", line=dict(color='#54c4f4')))
    fig_third.add_trace(
        go.Scatter(name="RMSD", x=x_3_axis,
                   y=y_3_axis2, mode="markers", line=dict(color='Green')), secondary_y=True)
    # Vertical line indicating what is the value shown in the main graph
    fig_third.add_vline(x=number_ignored_data, line_width=3, line_dash="dot", opacity=0.25)

        # Add trace of the polynomial approximation
    #fig_second.add_trace(
        #go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users),
                   #y=np.polyval(polynum1, main.discrete_user_interval(users)), mode="lines", line=dict(color="Green")))
    #fig_second.add_trace(
    #    go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users),
    #               y=np.polyval(polynum2, main.discrete_user_interval(users)), mode="lines", line=dict(color="Blue")))
    #fig_second.add_trace(
    #    go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users),
    #               y=np.polyval(polynum3, main.discrete_user_interval(users)), mode="lines", line=dict(color="Red")))
    fig_second.add_trace(
        go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users),
                   y=np.polyval(logfit, np.log(main.discrete_user_interval(users))), mode="lines", line=dict(color="Orange")))

    # Carrying capacity to be printed
    k_printed = int(np.rint(k)/pow(10, 6))
    k_printed = "{:,} M".format(k_printed)
    # PLATEAU: Time when the plateau is reached, assuming the plateau is "reached" when p(t)=95%*K
    print(p0)
    if p0 > 2.192572e-11:
        t_plateau = main.time_to_population(k, r, p0, 0.95*k) + 1970
        month_plateau = math.ceil((t_plateau - int(t_plateau))*12)
        year_plateau = int(np.round(t_plateau, 0))
        date_plateau = datetime.date(year_plateau, month_plateau, 1)
        date_plateau_displayed = date_plateau.strftime("%b, %Y")
        t_plateau_displayed = 'Year {:.1f}'.format(t_plateau)
    else:
        date_plateau_displayed = "Plateau could not be calculated"
    print("2. CALLBACK END")
    print(df_sorted)
    # print(polynum1)
    # print(-polynum1[1]/polynum1[0])
    print("K log")
    print(k_log,r_log,p0_log, r_squared_log)
    print(number_ignored_data)
    #for i in range(36):
        #k_log = k_scenarios[i]
        #r_log, p0_log, rsquared2 = main.logistic_parameters_given_K(dates[i:], users[i:], k_log)
        #print(i, k_log, r_log, p0_log, rsquared2)
        #fig_second.add_trace(
         #   go.Scatter(name="Discrete Growth Rate", x=main.discrete_user_interval(users),
         #              y=-r_log / k_log * main.discrete_user_interval(users) + r_log, mode="lines"))

    # Analysis test to be deleted


    return fig_main, fig_second, fig_third, k_printed, sections, date_plateau_displayed, marks, data_ignored_array[-1], \
        marks_slider, False, graph_message

@app.callback(
    Output("offcanvas", "is_open"),
    Input("open-offcanvas", "n_clicks"),
    [State("offcanvas", "is_open")],
)
def toggle_offcanvas(n1, is_open):
    if n1:
        return not is_open
    return is_open




if __name__ == '__main__':
    app.run_server(debug=True)